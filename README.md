# Test Runners and Frameworks

| Helpful Industry Terms |  |
| ---- | ---- |
| Feature | Group of user flows in your app (e.g., Login) |
| Testcase | A single possible path through a feature |
| Testsuite | A group of testcases that run together |
| Build | The system(s) that compile and test an app |
| Continuous Integration (CI) Server | System for defining and running builds |
| Test Runner | Program that collects and runs testcases| 
| Test Framework | 1st or 3rd party tooling to handle or abstract away common test-writing tasks |

Let's talk about test runners and frameworks, which will be the technical garden bed within which your testsuite will grow. But first, let's give a little glossary of terms to make sure we're all on the same page about everything that we've been talking about and will be talking about.

1. Feature. When I talk about a feature, I mean a general app feature that the user might move through in multiple ways. Login is a feature that we want to test, for example, but a test of the login feature will actually consist of multiple test cases.
2. Testcase. A test case is an extraction of a single possible path through a feature. It might be a positive testcase, like the happy path case we talked about earlier. Or it might be a negative testcase, designed to test the app behaves properly when the user input is invalid, and so on.
3. Test suite. A suite is a set of testcases that are grouped together for some reason or another. It could be simply all the testcases, or it could be the smoke tests or the regression tests.
4. Build. Sometimes, we use the word build to refer to the test suite, but that's not totally accurate. The word build comes from software development more than testing, and it refers to the process by which an app is compiled and all its components brought together and made ready to run. Nowadays, automated tests are considered to be part of a build, even though they're usually not part of the app compilation step, and even though the app is usually ready to run before it's tested. Build can refer to the overall system including compilation, testing, and reporting. It can also refer to a particular instance or run of those systems. So, for example, I could say, "our build is slow," meaning that the whole pipeline is generally slow. Or I could say, "that build was slow," referring to a specific run of the tests. Context should make it clear which is meant.
5. Continuous Integration Server or CI server. This is a server that usually has a web app running on the front end, which you either host yourself or use in another hosted environment. CI servers allow you to define pipelines of functionality that should run when different actions take place. For example, if a developer makes a change to the app and proposes it on GitHub, a CI server might automatically pick up that change, then build the new version of the app, then run a test server with the app's web backend, then pass the built app to an Appium testsuite to run on devices, and then gather data from the testsuite, and then finally determine whether a build actually passed. The website for the CI server would allow you to configure all of this or view the history of previous builds so you have an idea of the health of your app and of your build pipeline.
6. Test runner. A test runner is a program that will find and collect testcases, run them in the programming language you have adopted, and provide reports about which tests passed and failed. The test runner we'll be using in this course is called pytest. Since we're using Pytest, we don't have to worry about building fancy reporters for our tests. And Pytest can also easily be integrated with CI servers.
7. Test framework. A test framework is a collection of classes and utilities that make your life easier when writing tests. There's really two levels of a test framework. One is the standard test tooling that comes with any generic framework you might use. This would include features like conventions for defining tests, the ability to specify the set up or clean up behavior for groups of tests, and so on. Pytest is also a test framework in this sense. Most test runners are also test frameworks in this sense, in that they provide the basic patterns and conventions for writing your tests. But typically we also build our own framework on top of them, in a way which is custom for our own app or in a way which is generic to Appium or Selenium. So in our custom framework we might create a base class which has utilities for finding elements in our app, or starting sessions, or custom expected conditions that make sense for us. Basically anything which we notice is useful in more than one place in our testsuite is a good candidate for becoming part of our test framework. And the framework we end up using is almost always a hybrid of some open source framework like Pytest, plus all the custom stuff that we build on top that's useful throughout our testsuite.

